use super::stream::ClassOutputStream;
use super::stream::ClassInputStream;
use super::stream::ClassInputStreamError;
use super::stream::ClassStreamEntry;
use super::stream::ReadChunks;
use super::stream::WriteChunks;
use super::constant::ConstantPool;
use super::attribute::Attribute;

#[derive(Default)]
pub struct Class {
    pub version: ClassfileVersion,
    pub constant_pool: ConstantPool,
    pub access_flags: AccessFlags,
    pub this_class: ConstantPoolIndex,
    pub super_class: ConstantPoolIndex,
    pub interfaces: Vec<ConstantPoolIndex>,
    pub fields: Vec<Field>,
    pub methods: Vec<Method>,
    pub attributes: Vec<Attribute>
}

impl ClassStreamEntry for Class {

    fn read_element(stream: &ClassInputStream) -> Result<Self, ClassInputStreamError> {
        Err(ClassInputStreamError::NotImplemented)
    }

    fn write_element(&self, stream: &mut ClassOutputStream) {
    }
}

pub struct ClassfileVersion {
    pub minor_version: u16,
    pub major_version: u16
}

impl ClassfileVersion {
    pub fn new(major_version: u16, minor_version: u16) -> ClassfileVersion {
        ClassfileVersion { major_version: major_version, minor_version: minor_version }
    }

    pub fn has_lambdas(&self) -> bool {
        self.major_version >= 52
    }
}

impl Default for ClassfileVersion {
    fn default() -> ClassfileVersion {
        ClassfileVersion { major_version: 52, minor_version: 0 }
    }
}


impl ClassStreamEntry for ClassfileVersion {
    fn read_element(stream: &ClassInputStream) -> Result<Self, ClassInputStreamError> {
        match (stream.read_u16(), stream.read_u16()) {
            (Some(minor_version), Some(major_version)) => Ok(ClassfileVersion::new(major_version, minor_version)),
            _ => Err(ClassInputStreamError::PrematureEnd)
        }
    }

    fn write_element(&self, stream: &mut ClassOutputStream) {
        stream.write_u16(self.minor_version);
        stream.write_u16(self.major_version);
    }
}

#[derive(Default)]
pub struct AccessFlags {
    flags: u16
}

impl AccessFlags {
    pub fn new() -> AccessFlags {
        AccessFlags::of(0)
    }

    pub fn of(val: u16) -> AccessFlags {
        AccessFlags { flags: val }
    }

    pub fn has_flag(&self, flag: u16) -> bool {
        self.flags & flag > 0
    }

    pub fn set_flag(&mut self, flag: u16) {
        self.flags |= flag;
    }

    pub fn clear_flag(&mut self, flag: u16) {
        self.flags &= flag ^ 0xFFFF;
    }
}

pub enum ClassAccessFlags {
    PUBLIC = 0x0001,
    FINAL = 0x0010,
    SUPER = 0x0020,
    INTERFACE = 0x0200,
    ABSTRACT = 0x0400,
    SYNTHETIC = 0x1000,
    ANNOTATION = 0x2000,
    ENUM = 0x4000
}

pub enum FieldAccessFlags {
    PUBLIC = 0x0001, //	Declared public; may be accessed from outside its package.
    PRIVATE = 0x0002, //	Declared private; usable only within the defining class.
    PROTECTED = 0x0004, //	Declared protected; may be accessed within subclasses.
    STATIC = 0x0008, //	Declared static.
    FINAL = 0x0010, //	Declared final; never directly assigned to after object construction (JLS ยง17.5).
    VOLATILE = 0x0040, //	Declared volatile; cannot be cached.
    TRANSIENT = 0x0080, //	Declared transient; not written or read by a persistent object manager.
    SYNTHETIC = 0x1000, //	Declared synthetic; not present in the source code.
    ENUM = 0x4000 //	Declared as an element of an enum.
}

pub enum MethodAccessFlags {
    PUBLIC = 0x0001, //	Declared public; may be accessed from outside its package.
    PRIVATE = 0x0002, //	Declared private; accessible only within the defining class.
    PROTECTED = 0x0004, //	Declared protected; may be accessed within subclasses.
    STATIC = 0x0008, //	Declared static.
    FINAL = 0x0010, //	Declared final; must not be overridden (ยง5.4.5).
    SYNCHRONIZED = 0x0020, //	Declared synchronized; invocation is wrapped by a monitor use.
    BRIDGE = 0x0040, //	A bridge method, generated by the compiler.
    VARARGS = 0x0080, //	Declared with variable number of arguments.
    NATIVE = 0x0100, //	Declared native; implemented in a language other than Java.
    ABSTRACT = 0x0400, //	Declared abstract; no implementation is provided.
    STRICT = 0x0800, //	Declared strictfp; floating-point mode is FP-strict.
    SYNTHETIC = 0x1000 //	Declared synthetic; not present in the source code.
}

#[derive(Default)]
pub struct ConstantPoolIndex {
    pub idx: u16
}

impl ConstantPoolIndex {
    pub fn new() -> ConstantPoolIndex { ConstantPoolIndex::of(0) }
    pub fn of(idx: u16) -> ConstantPoolIndex { ConstantPoolIndex { idx: idx }}
}

impl ClassStreamEntry for ConstantPoolIndex {

    fn read_element(stream: &ClassInputStream) -> Result<Self, ClassInputStreamError> {
        match stream.read_u16() {
            Some(val) => Ok(ConstantPoolIndex::of(val)),
            _ => Err(ClassInputStreamError::PrematureEnd)
        }
    }

    fn write_element(&self, stream: &mut ClassOutputStream) {
        stream.write_u16(self.idx);
    }
}

#[derive(Default)]
pub struct Field {
    pub access_flags: AccessFlags,
    pub name_index: ConstantPoolIndex,
    pub descriptor_index: ConstantPoolIndex,
    pub attributes: Vec<Attribute>
}

#[derive(Default)]
pub struct Method {
    pub access_flags: AccessFlags,
    pub name_index: ConstantPoolIndex,
    pub descriptor_index: ConstantPoolIndex,
    pub attributes: Vec<Attribute>
}

impl ClassStreamEntry for Field {

    fn read_element(stream: &ClassInputStream) -> Result<Self, ClassInputStreamError> {
        match (stream.read_u16(), stream.read_u16(), stream.read_u16()) {
            (Some(access_flags), Some(name_index), Some(descriptor_index)) => {
                match stream.read_attributes() {
                    Ok(attributes) => Ok(Field {
                        access_flags: AccessFlags::of(access_flags),
                        name_index: ConstantPoolIndex::of(name_index),
                        descriptor_index: ConstantPoolIndex::of(descriptor_index),
                        attributes: attributes
                    }),
                    Err(err) => Err(err)
                }
            },
            _ => Err(ClassInputStreamError::PrematureEnd)
        }
    }

    fn write_element(&self, stream: &mut ClassOutputStream) {
    }
}

impl ClassStreamEntry for Method {

    fn read_element(stream: &ClassInputStream) -> Result<Self, ClassInputStreamError> {
        match (stream.read_u16(), stream.read_u16(), stream.read_u16()) {
            (Some(access_flags), Some(name_index), Some(descriptor_index)) => {
                match stream.read_attributes() {
                    Ok(attributes) => Ok(Method {
                        access_flags: AccessFlags::of(access_flags),
                        name_index: ConstantPoolIndex::of(name_index),
                        descriptor_index: ConstantPoolIndex::of(descriptor_index),
                        attributes: attributes
                    }),
                    Err(err) => Err(err)
                }
            },
            _ => Err(ClassInputStreamError::PrematureEnd)
        }
    }

    fn write_element(&self, stream: &mut ClassOutputStream) {
    }
}
